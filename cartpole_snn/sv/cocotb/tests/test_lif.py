"""
Cocotb tests for the LIF (Leaky Integrate-and-Fire) neuron module
based on snnTorch's Leaky neuron class.
Tests membrane dynamics, spike generation, and reset behavior.

Fixed-point format: QS2.13 (16-bit signed, 2 integer bits, 13 fractional bits)
- Scale factor: 2^13 = 8192
- Threshold 1.0 = 8192
- Beta 0.9 in Q1.7 = 115
"""

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import RisingEdge, ClockCycles

# Fixed-point format constants
TOTAL_BITS = 16  # Total bits in QS2.13 format
FRAC_BITS = 13   # Fractional bits

# Derived constants
SCALE_FACTOR = 2 ** FRAC_BITS           # 8192 for QS2.13
THRESHOLD = 2 ** FRAC_BITS              # 1.0 in fixed-point = 8192
MAX_SIGNED = 2 ** (TOTAL_BITS - 1) - 1  # 32767
MIN_SIGNED = -(2 ** (TOTAL_BITS - 1))   # -32768
UNSIGNED_RANGE = 2 ** TOTAL_BITS        # 65536

BETA = 0.9


def float_to_fixed(value: float) -> int:
    """Convert float to fixed-point (TOTAL_BITS-bit signed)."""
    scaled = int(round(value * SCALE_FACTOR))
    # Clamp to signed range
    if scaled > MAX_SIGNED:
        scaled = MAX_SIGNED
    elif scaled < MIN_SIGNED:
        scaled = MIN_SIGNED
    # Convert to unsigned for assignment (two's complement)
    if scaled < 0:
        scaled = scaled + UNSIGNED_RANGE
    return scaled


async def reset_dut(dut):
    """Apply reset sequence to the DUT and wait for it to stabilize."""
    dut.reset.value = 1
    dut.enable.value = 0
    dut.current.value = 0
    await ClockCycles(dut.clk, 5)
    dut.reset.value = 0
    await ClockCycles(dut.clk, 2)


# def fixed_to_float(value: int) -> float:
#     """Convert fixed-point to float."""
#     # Handle as signed
#     if value >= 2 ** (TOTAL_BITS - 1):
#         value = value - UNSIGNED_RANGE
#     return value / SCALE_FACTOR


@cocotb.test()
async def test_lif_reset(dut):
    """Test that reset properly initializes the LIF neuron."""

    # Start clock (10ns period = 100MHz)
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())

    # Apply reset
    dut.reset.value = 1
    dut.enable.value = 0
    dut.current.value = 0

    await ClockCycles(dut.clk, 5)

    # Check reset state
    assert dut.spike.value == 0, "spike should be 0 after reset"

    dut._log.info("Reset test passed")


@cocotb.test()
async def test_lif_no_spike_below_threshold(dut):
    """Test that neuron doesn't spike when input is below threshold."""

    # Start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())

    await reset_dut(dut)

    # Apply small input (0.1) for several cycles
    small_input = float_to_fixed(0.1)
    dut.current.value = small_input
    dut.enable.value = 1

    # Run for 5 cycles - membrane should accumulate but not spike
    # With beta=0.9, membrane = 0.1 + 0.9*0.1 + 0.9^2*0.1 + ... < 1.0
    for i in range(5):
        await RisingEdge(dut.clk)
        spike = int(dut.spike.value)
        dut._log.info(f"Cycle {i+1}: spike={spike}")
        assert spike == 0, f"Should not spike on cycle {i+1} with small input"

    dut._log.info("No spike below threshold test passed")


@cocotb.test()
async def test_lif_spike_above_threshold(dut):
    """Test that neuron spikes when membrane exceeds threshold."""

    # Start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())

    await reset_dut(dut)

    # Apply large input (1.5) - should spike immediately
    large_input = float_to_fixed(1.5)
    dut.current.value = large_input
    dut.enable.value = 1

    await RisingEdge(dut.clk)
    await RisingEdge(dut.clk)  # Need one more cycle to see spike output

    spike = int(dut.spike.value)
    dut._log.info(f"Spike with large input (1.5): {spike}")
    assert spike == 1, "Should spike when input exceeds threshold"

    dut._log.info("Spike above threshold test passed")


@cocotb.test()
async def test_lif_membrane_accumulation(dut):
    """Test that membrane potential accumulates over time and eventually spikes."""

    # Start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())

    await reset_dut(dut)

    # Apply moderate input (0.3) repeatedly
    # With beta=0.9, membrane accumulates: 0.3, 0.3+0.27, 0.3+0.27+0.243, ...
    # Converges to 0.3/(1-0.9) = 3.0, so should spike
    moderate_input = float_to_fixed(0.3)
    dut.current.value = moderate_input
    dut.enable.value = 1

    spike_detected = False
    for i in range(20):
        await RisingEdge(dut.clk)
        spike = int(dut.spike.value)
        if spike == 1:
            dut._log.info(f"Spike detected on cycle {i+1}")
            spike_detected = True
            break

    assert spike_detected, "Should have spiked with accumulated membrane potential"
    dut._log.info("Membrane accumulation test passed")


@cocotb.test()
async def test_lif_consecutive_spiking(dut):
    """Test that neuron can spike on consecutive cycles with high sustained input."""

    # Start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())

    await reset_dut(dut)

    # Apply input that will cause spike (1.2)
    input_val = float_to_fixed(1.2)
    dut.current.value = input_val
    dut.enable.value = 1

    # Wait for spike
    await RisingEdge(dut.clk)
    await RisingEdge(dut.clk)

    first_spike = int(dut.spike.value)
    dut._log.info(f"First spike: {first_spike}")
    assert first_spike == 1, "Should spike with input 1.2"

    # Continue with same input - reset-by-subtraction should reduce membrane
    # After spike: membrane = beta * (1.2) + 1.2 - 1.0 = 1.08 + 1.2 - 1.0 = 1.28
    # Should spike again
    await RisingEdge(dut.clk)
    second_spike = int(dut.spike.value)
    dut._log.info(f"Second spike: {second_spike}")

    # With continuous 1.2 input, neuron should keep spiking
    assert second_spike == 1, "Should spike again with sustained high input"

    dut._log.info("Consecutive spiking test passed")


@cocotb.test()
async def test_lif_reset_by_subtraction(dut):
    """Test that reset-by-subtraction prevents immediate re-spike.

    With input=0.55 and beta=0.9:
    - Cycle 1: membrane = 0.55 (no spike)
    - Cycle 2: membrane = 0.9*0.55 + 0.55 = 1.045 (spike)
    - Cycle 3: membrane = 0.9*(1.045 - 1.0) + 0.55 = 0.59 (no spike due to reset)
    This demonstrates that reset-by-subtraction reduces membrane by threshold.
    """

    # Start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())

    await reset_dut(dut)

    # Apply input that will spike after accumulation but not immediately re-spike
    input_val = float_to_fixed(0.55)
    dut.current.value = input_val
    dut.enable.value = 1

    # Cycle 1: membrane = 0.55, no spike
    await RisingEdge(dut.clk)
    await RisingEdge(dut.clk)
    spike1 = int(dut.spike.value)
    dut._log.info(f"Cycle 1 spike: {spike1}")
    assert spike1 == 0, "Should not spike on cycle 1 (membrane = 0.55)"

    # Cycle 2: membrane = 0.9*0.55 + 0.55 = 1.045, spike
    await RisingEdge(dut.clk)
    spike2 = int(dut.spike.value)
    dut._log.info(f"Cycle 2 spike: {spike2}")
    assert spike2 == 1, "Should spike on cycle 2 (membrane = 1.045)"

    # Cycle 3: membrane = 0.9*(1.045 - 1.0) + 0.55 = 0.59, no spike
    # This is the key assertion - reset-by-subtraction prevents immediate re-spike
    await RisingEdge(dut.clk)
    spike3 = int(dut.spike.value)
    dut._log.info(f"Cycle 3 spike: {spike3}")
    assert spike3 == 0, "Should NOT spike on cycle 3 due to reset-by-subtraction"

    dut._log.info("Reset by subtraction test passed")


@cocotb.test()
async def test_lif_enable_hold_state(dut):
    """Test that state is held when enable is low."""

    # Start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())

    await reset_dut(dut)

    # Apply input and enable for a few cycles
    dut.current.value = float_to_fixed(0.3)
    dut.enable.value = 1
    await ClockCycles(dut.clk, 3)

    # Disable and check state holds
    dut.enable.value = 0
    spike_before = int(dut.spike.value)

    # Run several cycles with enable=0
    for i in range(5):
        await RisingEdge(dut.clk)
        spike_after = int(dut.spike.value)
        assert spike_after == spike_before, f"Spike state should hold when enable=0 (cycle {i+1})"

    dut._log.info("Enable hold state test passed")


@cocotb.test()
async def test_lif_negative_input(dut):
    """Test neuron behavior with negative input current."""

    # Start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())

    await reset_dut(dut)

    # Apply negative input (-0.5)
    negative_input = float_to_fixed(-0.5)
    dut.current.value = negative_input
    dut.enable.value = 1

    # Should never spike with negative input
    for i in range(10):
        await RisingEdge(dut.clk)
        spike = int(dut.spike.value)
        assert spike == 0, f"Should not spike with negative input (cycle {i+1})"

    dut._log.info("Negative input test passed")


@cocotb.test()
async def test_lif_beta_decay(dut):
    """Test that membrane decays when input is removed."""

    # Start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())

    await reset_dut(dut)

    # Build up some membrane potential (but not enough to spike)
    dut.current.value = float_to_fixed(0.5)
    dut.enable.value = 1
    await ClockCycles(dut.clk, 2)  # membrane ~ 0.5 + 0.45 = 0.95

    # Remove input
    dut.current.value = 0

    # Membrane should decay toward 0 with beta=0.9
    # After removing input, membrane should decrease each cycle
    # We just verify no spike occurs and the neuron stays quiet
    for i in range(10):
        await RisingEdge(dut.clk)
        spike = int(dut.spike.value)
        assert spike == 0, f"Should not spike during decay (cycle {i+1})"

    dut._log.info("Beta decay test passed")
